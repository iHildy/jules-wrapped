#!/usr/bin/env node

import { spawnSync } from "node:child_process";
import fs from "node:fs";
import { dirname, join } from "node:path";
import { platform as osPlatform, arch as osArch } from "node:os";
import { fileURLToPath } from "node:url";
import { createRequire } from "node:module";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const require = createRequire(import.meta.url);

function run(target) {
  const result = spawnSync(target, process.argv.slice(2), {
    stdio: "inherit",
  });
  if (result.error) {
    console.error(result.error.message);
    process.exit(1);
  }
  const code = typeof result.status === "number" ? result.status : 0;
  process.exit(code);
}

/**
 * Detect if the system uses musl libc
 */
function isMusl() {
  if (osPlatform() !== "linux") return false;
  try {
    const lddOutput = spawnSync("ldd", ["--version"], { encoding: "utf8" }).stdout || "";
    if (lddOutput.toLowerCase().includes("musl")) return true;
    if (fs.readdirSync("/lib").some((f) => f.startsWith("ld-musl-"))) return true;
  } catch (e) {}
  return false;
}

/**
 * Detect if the CPU supports AVX2 (simple check)
 */
function isAVX2() {
  if (osArch() !== "x64") return true;
  try {
    if (osPlatform() === "linux") {
      return fs.readFileSync("/proc/cpuinfo", "utf8").includes("avx2");
    }
    if (osPlatform() === "darwin") {
      return spawnSync("sysctl", ["-n", "machdep.cpu.features"], { encoding: "utf8" }).stdout.includes("avx2");
    }
  } catch (e) {}
  return true;
}

const platformMap = {
  darwin: "darwin",
  linux: "linux",
  win32: "windows",
};
const archMap = {
  x64: "x64",
  arm64: "arm64",
};

let platform = platformMap[osPlatform()] || osPlatform();
let arch = archMap[osArch()] || osArch();

// Build priority list of package names
const pkgNames = [];
const parts = ["jules-wrapped", platform, arch];

if (arch === "x64" && !isAVX2()) {
  if (platform === "linux" && isMusl()) {
    pkgNames.push(parts.join("-") + "-baseline-musl");
  }
  pkgNames.push(parts.join("-") + "-baseline");
}

if (platform === "linux" && isMusl()) {
  pkgNames.push(parts.join("-") + "-musl");
}

pkgNames.push(parts.join("-"));

const binary = platform === "windows" ? "jules-wrapped.exe" : "jules-wrapped";

function findBinary() {
  // 1. Try require.resolve for each possible package
  for (const name of pkgNames) {
    try {
      const pkgJson = require.resolve(`${name}/package.json`);
      const binPath = join(dirname(pkgJson), "bin", binary);
      if (fs.existsSync(binPath)) return binPath;
    } catch (e) {}
  }

  // 2. Fallback to manual search (useful for some pnpm/npx edge cases)
  // We search for node_modules in parents, and then look for the binary in siblings of 'jules-wrapped'
  let current = __dirname;
  for (;;) {
    const modules = join(current, "node_modules");
    if (fs.existsSync(modules)) {
      for (const name of pkgNames) {
        const candidate = join(modules, name, "bin", binary);
        if (fs.existsSync(candidate)) return candidate;
      }
    }
    
    // Specifically check sibling directories in node_modules
    // If current is '.../node_modules/jules-wrapped/bin', then dirname(dirname(current)) is '.../node_modules'
    if (current.includes("jules-wrapped")) {
       const possibleNodeModules = current.split("jules-wrapped")[0];
       if (possibleNodeModules.endsWith("node_modules/") || possibleNodeModules.endsWith("node_modules")) {
          for (const name of pkgNames) {
            const candidate = join(possibleNodeModules, name, "bin", binary);
            if (fs.existsSync(candidate)) return candidate;
          }
       }
    }

    const parent = dirname(current);
    if (parent === current) break;
    current = parent;
  }
}

const resolved = findBinary();
if (!resolved) {
  console.error(
    `Error: Could not find the native binary for your platform (${platform}-${arch}).\n` +
    `Tried packages: ${pkgNames.join(", ")}\n` +
    `Please try reinstalling the package or report an issue at https://github.com/iHildy/jules-wrapped/issues`
  );
  process.exit(1);
}

run(resolved);
